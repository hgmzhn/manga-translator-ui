# 后端技术细节：参数计算、蒙版与数据导出

本文档旨在详细记录和总结关于漫画图片翻译器项目中，后端在处理图像和文本时，几个核心环节的技术原理。

---

## 1. 后端关键参数的计算来源

JSON文件中每个字段的值都是后端流水线在不同阶段计算的结果。

### 1.1. `font_size` (字体大小) 的完整生命周期

`font_size` 是一个在处理流程中被多次计算和调整的关键参数，其最终值决定了渲染文本的大小。它的生命周期主要分为三个阶段：

1.  **阶段一：初始估算 (文本检测)**
    `font_size` 的最源头是在文本检测阶段。对于每一个检测到的最小文本行（`Quadrilateral` 对象），其 `font_size` 被估算为该行几何边界框的**较短边的长度**。这部分逻辑发生在底层的文本检测模型中，为后续步骤提供了基础数据。

2.  **阶段二：合并取最小值 (`textline_merge/__init__.py`)**
    当多个独立的 `TextLine` 被合并成一个逻辑上的 `TextBlock` 时，`font_size` 会被重新计算。代码明确规定，新创建的 `TextBlock` 的 `font_size` 被设为所有构成它的 `TextLine` 中**最小的那个 `font_size`** (`min([txtln.font_size for txtln in txtlns])`)。这确保了合并后的文本块的初始字体大小不会超过其中任何一个原始部分。

3.  **阶段三：渲染时动态调整 (`rendering/__init__.py`)**
    这是 `font_size` 变化最复杂的阶段，发生在最终渲染文本之前，由 `resize_regions_to_font_size` 函数完成。调整逻辑如下：
    *   **确定基础值**: 首先，根据用户配置，确定一个基础字体大小。如果设置了**固定字体大小** (`font_size_fixed`)，则直接使用该值；否则，使用 `TextBlock` 当前的 `font_size`（即阶段二的最小值）加上一个**偏移量** (`font_size_offset`)。
    *   **应用最小限制**: 计算出一个**最小字体大小** (`font_size_minimum`)，该值通常与图像的整体尺寸有关（图像越大，允许的最小字体也越大），确保字体大小不低于此限制。
    *   **根据译文长度缩放**: 程序会计算原文和译文渲染后所需的**像素面积比**。如果译文比原文长，字体大小会按此比例**相应增大**；反之则**适当缩小**。
    *   **最终赋值**: 经过上述一系列计算和调整后，最终得到的 `font_size` 会被重新赋值给 `TextBlock` 对象，用于最终的文本渲染。

### 1.2. 其他关键参数的来源

- **`text` / `texts`**：直接来自OCR引擎对图片内容的识别结果。
- **`angle`**：由合并前的所有独立文本行的角度值取**平均值**得到。
- **`center`**：一个**派生属性**，由 `lines` 坐标动态计算得出，是所有多边形总外接矩形的中心。
- **`fg_colors` / `bg_colors`**：由构成文本框的所有独立文本行的颜色取**平均值**得到。单行的颜色则是在OCR阶段通过分析其框内像素得出。
- **`direction` / `alignment`**：**智能推断属性**。主要根据目标语言的习惯（如英文横排，日文自动）和文本框自身的宽高比来自动决定。

---

## 2. 文本布局计算 (换行与排版)

在渲染文本前，后端会通过一系列复杂的“文字计算”来决定如何将一长串翻译文本优美地放入形状不规则的文本框中。这个过程主要由 `text_render.py` 中的 `calc_horizontal` 和 `calc_vertical` 函数完成。

### 2.1. 横排文本 (`calc_horizontal`)

这是处理西文等横排文字的核心逻辑，目标是在给定的**最大宽度 (`max_width`)** 内进行智能换行。

1.  **单词与音节拆分**：程序首先会将文本字符串拆分成独立的**单词**，并为每个单词预计算其像素宽度。
2.  **连字符支持**：根据目标语言（`target_lang`），程序会加载一个**连字符库 (Hyphenator)**。然后，它会将每个单词进一步拆分为**音节**。这是实现西文优雅换行的关键，允许在单词的音节之间进行分割并添加连字符`-`。
3.  **逐行填充**：程序会逐个音节地向当前行中添加内容，并累加计算当前行的总像素宽度。
4.  **换行决策**：一旦添加下一个音节会导致当前行超出 `max_width`，程序就会决定在此处换行。
5.  **智能优化**：换行算法还包含一些优化逻辑，例如，它会尝试在两行之间移动单词或音节，以避免某一行过长而另一行过短，或避免在行尾留下一个非常短的单词（孤词），使整体布局更美观。

### 2.2. 竖排文本 (`calc_vertical`)

处理中日韩等竖排文字的逻辑相对简单一些。

1.  **逐字填充**：程序会逐个字符地向当前列中添加内容，并累加计算当前列的总像素高度。
2.  **换列决策**：一旦添加下一个字符会导致当前列超出**最大高度 (`max_height`)**，程序就会换到新的一列。
3.  **特殊字符处理**：此函数还会处理竖排标点符号的转换。例如，它会将横排的括号 `()` 转换为竖排的 `︵︶`，将横排的破折号 `—` 转换为竖排的 `︱`，以符合竖排书写规范。

### 2.3. 动态边界框扩展

当译文远长于原文时，一个关键的挑战是如何在不溢出的情况下优雅地渲染文本。系统通过在 `calc_horizontal` 函数中实现的动态边界框扩展机制来解决这个问题。

1.  **面积预估与溢出判断**:
    *   在进行换行计算之前，函数会首先估算渲染所有译文所需的总像素面积 (`expected_size`)。
    *   接着，它会计算原始文本框所能提供的最大渲染面积 (`max_size`)，即 `max_width` 乘以 `max_lines`（基于 `max_height` 和 `font_size` 计算出的最大行数）。
    *   如果 `expected_size` 大于 `max_size`，则判定文本会溢出。

2.  **计算与应用扩展系数**:
    *   一旦检测到溢出，程序会计算一个扩展系数 `multiplier`。该系数约等于 **所需面积** 与 **可用面积**之比的平方根 (`sqrt(expected_size / max_size)`)，并确保最小增幅（例如，至少乘以 `1.05`）。
    *   `max_width` 和 `max_height` 这两个用于布局计算的边界值，会直接乘以该 `multiplier`。

3.  **循环验证**:
    *   这个扩展过程在一个 `while` 循环中执行。在每次扩展后，程序会重新进行面积预估和溢出判断，直到 `max_size` 足以容纳 `expected_size` 为止。

通过这种方式，渲染引擎并非直接比较原文和译文的字符串长度，而是基于更精确的渲染面积需求来动态、按比例地扩大文本框的有效渲染区域，从而确保长译文也能被完整、美观地渲染出来。

---

## 3. 文字擦除与蒙版（Mask）技术

文字擦除（Inpainting）功能依赖于精确的蒙版。

- **原始蒙版 (Raw Mask)**：由文字检测AI模型直接生成，是一张包含噪点和模糊边缘的原始概率图，是后续处理的“**原料**”。
- **精炼蒙版 (Refined Mask)**：这是最终用于文字擦除的蒙版。它**不是**两个蒙版的简单结合，而是通过一个“筛选和修正”的过程产生的：
    1.  以文本框的 `lines` 坐标（几何形状）为基准。
    2.  去“筛选”原始蒙版中的像素团块，只保留那些落在 `lines` 区域内的像素。
    3.  对保留下来的像素团块，再结合原始图像的颜色信息进行边缘优化，最终生成一个干净、精确的蒙版。
    4.  **只有这个最终的“精炼蒙版”会被交给擦除算法使用。**

---

## 4. 最终导出的数据字段

根据您的要求，我们对后端的导出逻辑 (`TextBlock.to_dict`) 进行了精简，现在导出的JSON文件中，每个文本区域只包含以下由当前渲染管线**实际使用或间接影响**的字段：

- `lines`
- `texts`
- `text`
- `translation`
- `angle`
- `font_size`
- `fg_colors`
- `bg_colors`
- `direction`
- `alignment`
- `target_lang`
- `source_lang`
- `line_spacing`
- `default_stroke_width`
- `adjust_bg_color`
- `prob` (置信度，因其在过滤时有价值而保留)

所有与高级样式（如阴影、不透明度、字重等）相关的、当前版本未使用的字段已被移除，使数据文件更加清晰和高效。

---

## 5. TextBlock 对象的生命周期与数据演变

`TextBlock` 对象是后端处理的核心数据结构，它代表一个独立的文本区域。从最初的检测到最终的渲染，`TextBlock` 的内部数据会经历一系列复杂的创建、修改和验证过程。

### 5.1. 阶段一：创建与初始化

1.  **文本行检测 (`_run_detection`)**: 流水线的第一步是在图像上检测出多个独立的、小块的文本行 (`TextLine`)。此时的数据还不是 `TextBlock`。
2.  **OCR (`_run_ocr`)**: 对每个 `TextLine` 进行文字识别，填充其 `text` 属性。
3.  **合并与创建 (`_run_textline_merge`)**: 这是 `TextBlock` 诞生的关键阶段。系统会根据几何位置和方向，将多个相关的 `TextLine` 合并成一个逻辑区域，并创建一个 `TextBlock` 对象。
    *   **`lines`**: 继承自所有合并的 `TextLine` 的坐标。
    *   **`text`**: 由所有 `TextLine` 的 `text` 合并而成。
    *   **`text_raw`**: `text` 的一个永久副本，用于后续的比较和渲染。
    *   **`angle`, `fg_colors`, `bg_colors`**: 根据合并的 `TextLine` 计算出初始的平均值。

### 5.2. 阶段二：翻译与内容增强

1.  **翻译前词典 (`apply_dictionary`)**: 如果提供了前置词典，`TextBlock` 的 `text` 属性会在此阶段被第一次修改。
2.  **核心翻译 (`_run_text_translation`)**:
    *   将 `text` 属性发送给翻译引擎。
    *   返回的结果被存入全新的 `translation` 属性中。
    *   同时，`target_lang` (目标语言), `_alignment` (对齐方式), 和 `_direction` (方向) 等渲染所需的元数据也被设置到 `TextBlock` 中。
3.  **翻译后处理 (`_apply_post_translation_processing`)**: 这是确保翻译质量的核心步骤，主要围绕 `translation` 属性进行：
    *   **标点修正**: 自动修正中英文标点，例如将 `""` 替换为 `「」`。
    *   **翻译后词典**: 应用后置词典，对 `translation` 进行再次修正。
    *   **幻觉检测 (`_check_repetition_hallucination`)**: 检查 `translation` 中是否存在不自然的重复内容（如 “你好你好你好”），这是大语言模型常见的错误。
    *   **语言验证 (`_check_target_language_ratio`)**: 验证 `translation` 的语言是否确实是目标语言。
    *   **重试机制 (`_retry_translation_with_validation`)**: 如果上述任意检查失败，系统会自动对这个 `TextBlock` 发起一次全新的翻译请求，并重复验证流程。

### 5.3. 阶段三：最终确定与渲染

1.  **过滤**: 在所有内容处理完成后，系统会根据一系列规则（如译文为空、译文与原文完全相同、只包含数字等）过滤掉无效的 `TextBlock`。只有通过过滤的 `TextBlock` 才会进入最终的渲染流程。
2.  **蒙版精炼 (`_run_mask_refinement`)**: 使用最终确定的 `TextBlock` 的 `lines` 坐标来精炼在检测阶段生成的原始蒙版（mask），得到一个与文本区域完美匹配的精确蒙版。
3.  **文本擦除 (`_run_inpainting`)**: 应用精炼后的蒙版，从原图中擦除原始文字。
4.  **渲染 (`_run_text_rendering`)**: 将 `TextBlock` 中最终版的 `translation` 文本，连同其 `font_size`, `angle`, `fg_colors` 等所有属性，一起渲染到被擦除后的图片上，完成整个翻译流程。
